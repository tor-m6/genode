diff -ru contrib/libgo-10be92754f6dbbd51b390bfdc9250f2b4370d9cb/src/lib/gcc/libgo/go/runtime/netpoll_kqueue.go inno/libgo/go/runtime/netpoll_kqueue.go
--- contrib/libgo-10be92754f6dbbd51b390bfdc9250f2b4370d9cb/src/lib/gcc/libgo/go/runtime/netpoll_kqueue.go	2018-01-09 02:23:08.000000000 +0100
+++ inno/libgo/go/runtime/netpoll_kqueue.go	2021-01-26 12:24:35.097121371 +0100
@@ -2,20 +2,56 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.

-// +build darwin dragonfly freebsd netbsd openbsd
+// +build darwin dragonfly freebsd netbsd openbsd inno

 package runtime

 // Integrated network poller (kqueue-based implementation).

-import "unsafe"
+import (
+	"unsafe"
+)
+
+type fds_bits_type uint64
+
+const nfdbits = int32(unsafe.Sizeof(fds_bits_type(0)) * 8)
+
+type Timeval struct {
+	Sec  int64
+	Usec int64
+}

-//extern kqueue
-func kqueue() int32
+const FD_SETSIZE = 1024
+
+type FdSet struct {
+	Bits [(FD_SETSIZE + nfdbits - 1) / nfdbits]fds_bits_type
+}
+
+func FDSet(fd int32, set *FdSet) {
+	set.Bits[fd/nfdbits] |= (1 << (uint)(fd%nfdbits))
+}
+
+func FDClr(fd int32, set *FdSet) {
+	set.Bits[fd/nfdbits] &^= (1 << (uint)(fd%nfdbits))
+}
+
+func FDIsSet(fd int32, set *FdSet) bool {
+	if set.Bits[fd/nfdbits]&(1<<(uint)(fd%nfdbits)) != 0 {
+		return true
+	} else {
+		return false
+	}
+}
+
+func FDZero(set *FdSet) {
+	for i := range set.Bits {
+		set.Bits[i] = 0
+	}
+}

 //go:noescape
-//extern kevent
-func kevent(kq int32, ch *keventt, nch uintptr, ev *keventt, nev uintptr, ts *timespec) int32
+//extern select
+func c_select(nfd int32, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) int32

 //extern __go_fcntl_uintptr
 func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)
@@ -25,45 +61,61 @@
 }

 var (
-	kq int32 = -1
+	global_pd   []*pollDesc = make([]*pollDesc, _FD_SETSIZE+1)
+	global_fds0 FdSet
+	global_fds1 FdSet
+	fds               = make([]int32, _FD_SETSIZE+1)
+	max_fd      int32 = 0
+	current_fd  int32 = 0
 )

 func netpollinit() {
-	kq = kqueue()
-	if kq < 0 {
-		println("netpollinit: kqueue failed with", errno())
-		throw("runtime: netpollinit failed")
-	}
-	closeonexec(kq)
 }

 func netpolldescriptor() uintptr {
-	return uintptr(kq)
+	return 0
 }

-func netpollopen(fd uintptr, pd *pollDesc) int32 {
-	// Arm both EVFILT_READ and EVFILT_WRITE in edge-triggered mode (EV_CLEAR)
-	// for the whole fd lifetime. The notifications are automatically unregistered
-	// when fd is closed.
-	var ev [2]keventt
-	*(*uintptr)(unsafe.Pointer(&ev[0].ident)) = fd
-	ev[0].filter = _EVFILT_READ
-	ev[0].flags = _EV_ADD | _EV_CLEAR
-	ev[0].fflags = 0
-	ev[0].data = 0
-	ev[0].udata = (*byte)(unsafe.Pointer(pd))
-	ev[1] = ev[0]
-	ev[1].filter = _EVFILT_WRITE
-	n := kevent(kq, &ev[0], 2, nil, 0, nil)
-	if n < 0 {
-		return int32(errno())
+func netpollopen(fdp uintptr, pd *pollDesc) int32 {
+	fd := int32(fdp)
+	FDSet(fd, &global_fds0)
+	global_fds1 = global_fds0
+	global_pd[fd] = pd
+	fds[current_fd] = fd
+	if fd > max_fd {
+		max_fd = fd
 	}
+	current_fd++
 	return 0
 }

-func netpollclose(fd uintptr) int32 {
-	// Don't need to unregister because calling close()
-	// on fd will remove any kevents that reference the descriptor.
+func netpollclose(fdp uintptr) int32 {
+	fd := int32(fdp)
+	FDClr(fd, &global_fds0)
+	global_fds1 = global_fds0
+	global_pd[fd] = nil
+	var pos int32 = -1
+	for i := 0; i < len(fds); i++ {
+		if fds[i] == fd {
+			pos = int32(i)
+			break
+		}
+	}
+	if pos >= 0 {
+		// swap fds[pos] and the last element
+		fds[len(fds)-1], fds[pos] = fds[pos], fds[len(fds)-1]
+		// remove last element
+		fds = fds[:len(fds)-1]
+		if max_fd == fd {
+			// update max_fd
+			max_fd = -1
+			for i := 0; i < len(fds); i++ {
+				if fds[i] > max_fd {
+					max_fd = fds[i]
+				}
+			}
+		}
+	}
 	return 0
 }

@@ -71,57 +123,45 @@
 	throw("runtime: unused")
 }

+func Select(nfd int32, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) int {
+	_r := c_select(nfd, r, w, e, timeout)
+	return (int)(_r)
+}
+
 // Polls for ready network connections.
 // Returns list of goroutines that become runnable.
 func netpoll(block bool) *g {
-	if kq == -1 {
+	// FIXME:
+	if len(fds) == 0 {
 		return nil
 	}
-	var tp *timespec
-	var ts timespec
+	var tvp *Timeval = nil
 	if !block {
-		tp = &ts
+		tvp = new(Timeval)
+		tvp.Sec = 0
+		tvp.Usec = 0
 	}
-	var events [64]keventt
-retry:
-	n := kevent(kq, nil, 0, &events[0], uintptr(len(events)), tp)
-	if n < 0 {
-		e := errno()
-		if e != _EINTR {
-			println("runtime: kevent on fd", kq, "failed with", e)
+	var gp guintptr
+	for block && gp == 0 {
+		mfd := max_fd + 1
+		var fdr *FdSet = &global_fds0
+		var fdw *FdSet = &global_fds1
+		n := Select(mfd, fdr, fdw, nil, tvp)
+		if n < 0 {
 			throw("runtime: netpoll failed")
 		}
-		goto retry
-	}
-	var gp guintptr
-	for i := 0; i < int(n); i++ {
-		ev := &events[i]
-		var mode int32
-		switch ev.filter {
-		case _EVFILT_READ:
-			mode += 'r'
-
-			// On some systems when the read end of a pipe
-			// is closed the write end will not get a
-			// _EVFILT_WRITE event, but will get a
-			// _EVFILT_READ event with EV_EOF set.
-			// Note that setting 'w' here just means that we
-			// will wake up a goroutine waiting to write;
-			// that goroutine will try the write again,
-			// and the appropriate thing will happen based
-			// on what that write returns (success, EPIPE, EAGAIN).
-			if ev.flags&_EV_EOF != 0 {
+		for i := int32(1); i < mfd; i++ {
+			var mode int32
+			if FDIsSet(i, fdr) {
+				mode += 'r'
+			}
+			if FDIsSet(i, fdw) {
 				mode += 'w'
 			}
-		case _EVFILT_WRITE:
-			mode += 'w'
-		}
-		if mode != 0 {
-			netpollready(&gp, (*pollDesc)(unsafe.Pointer(ev.udata)), mode)
+			if mode != 0 {
+				netpollready(&gp, global_pd[i], mode)
+			}
 		}
 	}
-	if block && gp == 0 {
-		goto retry
-	}
 	return gp.ptr()
 }
