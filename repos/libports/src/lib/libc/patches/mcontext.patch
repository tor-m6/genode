diff -Naur src/lib/libc/sys/amd64/include/asm.h srn/lib/libc/sys/amd64/include/asm.h
--- src/lib/libc/sys/amd64/include/asm.h	2021-03-18 01:36:58.735793072 +0300
+++ srn/lib/libc/sys/amd64/include/asm.h	2021-03-17 23:59:50.903099829 +0300
@@ -98,4 +98,47 @@
 #define __FBSDID(s)	/* nothing */
 #endif /* !STRIP_FBSDID */
 
+/* generated offsets from mcontext main.cc */
+#define OF_mc_rbx 80
+#define OF_mc_rbp 88
+#define OF_mc_r8 56
+#define OF_mc_r9 64
+#define OF_mc_r10 96
+#define OF_mc_r11 104
+#define OF_mc_r12 112
+#define OF_mc_r13 120
+#define OF_mc_r14 128
+#define OF_mc_r15 136
+#define OF_mc_rdi 24
+#define OF_mc_rsi 32
+#define OF_mc_rdx 40
+#define OF_mc_rcx 48
+#define OF_mc_rip 176
+#define OF_mc_rsp 200
+#define OF_mc_fpstate 240
+#define OF_oMXCSR 264
+
+/* Makros to generate eh_frame unwind information.  */
+#ifdef __ASSEMBLER__
+#define cfi_startproc .cfi_startproc
+#define cfi_endproc .cfi_endproc
+#define cfi_def_cfa(reg, off) .cfi_def_cfa reg, off
+#define cfi_def_cfa_register(reg) .cfi_def_cfa_register reg
+#define cfi_def_cfa_offset(off) .cfi_def_cfa_offset off
+#define cfi_adjust_cfa_offset(off) .cfi_adjust_cfa_offset off
+#define cfi_offset(reg, off) .cfi_offset reg, off
+#define cfi_rel_offset(reg, off) .cfi_rel_offset reg, off
+#define cfi_register(r1, r2) .cfi_register r1, r2
+#define cfi_return_column(reg) .cfi_return_column reg
+#define cfi_restore(reg) .cfi_restore reg
+#define cfi_same_value(reg) .cfi_same_value reg
+#define cfi_undefined(reg) .cfi_undefined reg
+#define cfi_remember_state .cfi_remember_state
+#define cfi_restore_state .cfi_restore_state
+#define cfi_window_save .cfi_window_save
+#define cfi_personality(enc, exp) .cfi_personality enc, exp
+#define cfi_lsda(enc, exp) .cfi_lsda enc, exp
+
+#endif /* ! ASSEMBLER */
+
 #endif /* !_MACHINE_ASM_H_ */
diff -Naur src/lib/libc/lib/libc/amd64/sys/getcontext.S srn/lib/libc/lib/libc/amd64/sys/getcontext.S
--- src/lib/libc/lib/libc/amd64/sys/getcontext.S	2018-12-07 03:01:45.000000000 +0300
+++ srn/lib/libc/lib/libc/amd64/sys/getcontext.S	2021-03-18 02:15:01.714313690 +0300
@@ -37,12 +37,40 @@
 	WEAK_REFERENCE(__sys_getcontext, _getcontext)
 	WEAK_REFERENCE(__sys_getcontext, getcontext)
 ENTRY(__sys_getcontext)
-	movq	(%rsp),%rsi	/* save getcontext return address */
-	mov	$SYS_getcontext,%rax
-	KERNCALL
-	jb	HIDENAME(cerror)
-	addq	$8,%rsp		/* remove stale (setcontext) return address */
-	jmp	*%rsi		/* restore return address */
+	/* Save the preserved registers, the registers used for passing
+	   args, and the return address.  */
+	movq	%rbx, OF_mc_rbx(%rdi)
+	movq	%rbp, OF_mc_rbp(%rdi)
+	movq	%r12, OF_mc_r12(%rdi)
+	movq	%r13, OF_mc_r13(%rdi)
+	movq	%r14, OF_mc_r14(%rdi)
+	movq	%r15, OF_mc_r15(%rdi)
+
+	movq	%rdi, OF_mc_rdi(%rdi)
+	movq	%rsi, OF_mc_rsi(%rdi)
+	movq	%rdx, OF_mc_rdx(%rdi)
+	movq	%rcx, OF_mc_rcx(%rdi)
+	movq	%r8, OF_mc_r8(%rdi)
+	movq	%r9, OF_mc_r9(%rdi)
+
+	movq	(%rsp), %rcx
+	movq	%rcx, OF_mc_rip(%rdi)
+	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
+	movq	%rcx, OF_mc_rsp(%rdi)
+
+	/* We have separate floating-point register content memory on the
+	   stack.  We use the __fpregs_mem block in the context.  Set the
+	   links up correctly.  */
+
+	leaq	OF_mc_fpstate(%rdi), %rcx
+
+	/* Save the floating-point environment.  */
+	fnstenv	(%rcx)
+	fldenv	(%rcx)
+	stmxcsr OF_oMXCSR(%rdi)
+	/* All done, return 0 for success.  */
+	xorl	%eax, %eax
+	ret
 END(__sys_getcontext)
 
 	.section .note.GNU-stack,"",%progbits
diff -Naur src/lib/libc/lib/libc/amd64/sys/setcontext.S srn/lib/libc/lib/libc/amd64/sys/setcontext.S
--- src/lib/libc/lib/libc/amd64/sys/setcontext.S	1970-01-01 03:00:00.000000000 +0300
+++ srn/lib/libc/lib/libc/amd64/sys/setcontext.S	2021-03-18 02:15:33.995677853 +0300
@@ -0,0 +1,105 @@
+/*-
+ * Copyright (c) 2003 Peter Wemm <peter@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <machine/asm.h>
+__FBSDID("$FreeBSD: releng/12.0/lib/libc/amd64/sys/getcontext.S 258447 2013-11-21 21:25:58Z andreast $");
+
+#include <SYS.h>
+
+/*  int __setcontext (const ucontext_t *ucp)
+
+  Restores the machine context in UCP and thereby resumes execution
+  in that context.
+
+  This implementation is intended to be used for *synchronous* context
+  switches only.  Therefore, it does not have to restore anything
+  other than the PRESERVED state.  */
+	WEAK_REFERENCE(__sys_setcontext, _setcontext)
+	WEAK_REFERENCE(__sys_setcontext, setcontext)
+ENTRY(__sys_setcontext)
+	cfi_startproc
+	/* Save argument since syscall will destroy it.  */
+	pushq	%rdi
+	cfi_adjust_cfa_offset(8)
+
+	/* Pop the pointer into RDX. The choice is arbitrary, but
+	   leaving RDI and RSI available for use later can avoid
+	   shuffling values.  */
+	popq	%rdx
+	cfi_adjust_cfa_offset(-8)
+
+	/* Restore the floating-point context.  Not the registers, only the
+	   rest.  */
+	leaq	OF_mc_fpstate(%rdx), %rcx
+	fldenv	(%rcx)
+	ldmxcsr OF_oMXCSR(%rdx)
+
+
+	/* Load the new stack pointer, the preserved registers and
+	   registers used for passing args.  */
+	cfi_def_cfa(%rdx, 0)
+	cfi_offset(%rbx,OF_mc_rbx)
+	cfi_offset(%rbp,OF_mc_rbp)
+	cfi_offset(%r12,OF_mc_r12)
+	cfi_offset(%r13,OF_mc_r13)
+	cfi_offset(%r14,OF_mc_r14)
+	cfi_offset(%r15,OF_mc_r15)
+	cfi_offset(%rsp,OF_mc_rsp)
+	cfi_offset(%rip,OF_mc_rip)
+
+	movq	OF_mc_rsp(%rdx), %rsp
+	movq	OF_mc_rbx(%rdx), %rbx
+	movq	OF_mc_rbp(%rdx), %rbp
+	movq	OF_mc_r12(%rdx), %r12
+	movq	OF_mc_r13(%rdx), %r13
+	movq	OF_mc_r14(%rdx), %r14
+	movq	OF_mc_r15(%rdx), %r15
+
+	/* The following ret should return to the address set with
+	getcontext.  Therefore push the address on the stack.  */
+	movq	OF_mc_rip(%rdx), %rcx
+	pushq	%rcx
+
+	movq	OF_mc_rsi(%rdx), %rsi
+	movq	OF_mc_rdi(%rdx), %rdi
+	movq	OF_mc_rcx(%rdx), %rcx
+	movq	OF_mc_r8(%rdx), %r8
+	movq	OF_mc_r9(%rdx), %r9
+
+	/* Setup finally %rdx.  */
+	movq	OF_mc_rdx(%rdx), %rdx
+
+	/* End FDE here, we fall into another context.  */
+	cfi_endproc
+	cfi_startproc
+
+	/* Clear rax to indicate success.  */
+	xorl	%eax, %eax
+	ret
+	cfi_endproc
+END(__sys_setcontext)
+
+	.section .note.GNU-stack,"",%progbits
diff -Naur src/lib/libc/lib/libc/amd64/sys/swapcontext.S srn/lib/libc/lib/libc/amd64/sys/swapcontext.S
--- src/lib/libc/lib/libc/amd64/sys/swapcontext.S	1970-01-01 03:00:00.000000000 +0300
+++ srn/lib/libc/lib/libc/amd64/sys/swapcontext.S	2021-03-18 02:16:08.004061462 +0300
@@ -0,0 +1,132 @@
+/*-
+ * Copyright (c) 2003 Peter Wemm <peter@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <machine/asm.h>
+__FBSDID("$FreeBSD: releng/12.0/lib/libc/amd64/sys/getcontext.S 258447 2013-11-21 21:25:58Z andreast $");
+
+#include <SYS.h>
+
+/* int __swapcontext (ucontext_t *oucp, const ucontext_t *ucp);
+
+  Saves the machine context in oucp such that when it is activated,
+  it appears as if __swapcontextt() returned again, restores the
+  machine context in ucp and thereby resumes execution in that
+  context.
+
+  This implementation is intended to be used for *synchronous* context
+  switches only.  Therefore, it does not have to save anything
+  other than the PRESERVED state.  */
+
+	WEAK_REFERENCE(__sys_swapcontext, _swapcontext)
+	WEAK_REFERENCE(__sys_swapcontext, swapcontext)
+ENTRY(__sys_swapcontext)
+	cfi_startproc
+	/* Save the preserved registers, the registers used for passing args,
+	   and the return address.  */
+	movq	%rbx, OF_mc_rbx(%rdi)
+	movq	%rbp, OF_mc_rbp(%rdi)
+	movq	%r12, OF_mc_r12(%rdi)
+	movq	%r13, OF_mc_r13(%rdi)
+	movq	%r14, OF_mc_r14(%rdi)
+	movq	%r15, OF_mc_r15(%rdi)
+
+	movq	%rdi, OF_mc_rdi(%rdi)
+	movq	%rsi, OF_mc_rsi(%rdi)
+	movq	%rdx, OF_mc_rdx(%rdi)
+	movq	%rcx, OF_mc_rcx(%rdi)
+	movq	%r8, OF_mc_r8(%rdi)
+	movq	%r9, OF_mc_r9(%rdi)
+
+	movq	(%rsp), %rcx
+	movq	%rcx, OF_mc_rip(%rdi)
+	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
+	movq	%rcx, OF_mc_rsp(%rdi)
+
+	/* We have separate floating-point register content memory on the
+	   stack.  We use the __fpregs_mem block in the context.  Set the
+	   links up correctly.  */
+
+	leaq	OF_mc_fpstate(%rdi), %rcx
+
+	/* Save the floating-point environment.  */
+	fnstenv	(%rcx)
+	stmxcsr OF_oMXCSR(%rdi)
+
+
+	/* move second parameter address to rdx to keep compliance with original */
+	movq	%rsi, %rdx
+
+	/* Restore the floating-point context.  Not the registers, only the
+	   rest.  */
+	leaq	OF_mc_fpstate(%rdx), %rcx
+	fldenv	(%rcx)
+	ldmxcsr OF_oMXCSR(%rdx)
+
+	/* Load the new stack pointer and the preserved registers.  */
+	cfi_def_cfa(%rdx, 0)
+	cfi_offset(%rbx,OF_mc_rbx)
+	cfi_offset(%rbp,OF_mc_rbp)
+	cfi_offset(%r12,OF_mc_r12)
+	cfi_offset(%r13,OF_mc_r13)
+	cfi_offset(%r14,OF_mc_r14)
+	cfi_offset(%r15,OF_mc_r15)
+	cfi_offset(%rsp,OF_mc_rsp)
+	cfi_offset(%rip,OF_mc_rip)
+
+	movq	OF_mc_rsp(%rdx), %rsp
+	movq	OF_mc_rbx(%rdx), %rbx
+	movq	OF_mc_rbp(%rdx), %rbp
+	movq	OF_mc_r12(%rdx), %r12
+	movq	OF_mc_r13(%rdx), %r13
+	movq	OF_mc_r14(%rdx), %r14
+	movq	OF_mc_r15(%rdx), %r15
+
+	/* The following ret should return to the address set with
+	getcontext.  Therefore push the address on the stack.  */
+	movq	OF_mc_rip(%rdx), %rcx
+	pushq	%rcx
+
+	/* Setup registers used for passing args.  */
+	movq	OF_mc_rsi(%rdx), %rsi
+	movq	OF_mc_rdi(%rdx), %rdi
+	movq	OF_mc_rcx(%rdx), %rcx
+	movq	OF_mc_r8(%rdx), %r8
+	movq	OF_mc_r9(%rdx), %r9
+
+	/* Setup finally %rdx.  */
+	movq	OF_mc_rdx(%rdx), %rdx
+
+	/* End FDE here, we fall into another context.  */
+	cfi_endproc
+	cfi_startproc
+
+	/* Clear rax to indicate success.  */
+	xorl	%eax, %eax
+	ret
+	cfi_endproc
+END(__sys_swapcontext)
+
+	.section .note.GNU-stack,"",%progbits
